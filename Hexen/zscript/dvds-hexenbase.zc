class MaulotaurFriendBase : MaulotaurBase
{
	int StartTime;

	override void BeginPlay ()
	{
		Super.BeginPlay ();
		StartTime = -1;
	}

	override void Die (Actor source, Actor inflictor, int dmgflags)
	{
		Super.Die (source, inflictor, dmgflags);

		if (tracer && tracer.health > 0 && tracer.player)
		{
			// Search thinker list for minotaur
			ThinkerIterator it = ThinkerIterator.Create("MaulotaurFriendBase");
			MinotaurFriend mo;

			while ((mo = MinotaurFriend(it.Next())) != null)
			{
				if (mo.health <= 0) continue;
				// [RH] Minotaurs can't be morphed, so this isn't needed
				//if (!(mo.flags&MF_COUNTKILL)) continue;		// for morphed minotaurs
				if (mo.bCorpse) continue;
				if (mo.StartTime >= 0 && (level.maptime - StartTime) >= MAULATORTICS) continue;
				if (mo.tracer != null && mo.tracer.player == tracer.player) break;
			}

			if (mo == null)
			{
				Inventory power = tracer.FindInventory("PowerMinotaur");
				if (power != null)
				{
					power.Destroy ();
				}
			}
		}
	}
}

class KoraxBase : AetheriusBossZSC
{
	// Korax
	const KORAX_ARM_EXTENSION_SHORT	= 40;
	const KORAX_ARM_EXTENSION_LONG		= 55;

	const KORAX_ARM1_HEIGHT			= 108;
	const KORAX_ARM2_HEIGHT			= 82;
	const KORAX_ARM3_HEIGHT			= 54;
	const KORAX_ARM4_HEIGHT			= 104;
	const KORAX_ARM5_HEIGHT			= 86;
	const KORAX_ARM6_HEIGHT			= 53;

	const KORAX_FIRST_TELEPORT_TID		= 248;
	const KORAX_TELEPORT_TID			= 249;

	const KORAX_DELTAANGLE				= 85;

	const KORAX_COMMAND_HEIGHT			= 120;
	const KORAX_COMMAND_OFFSET			= 27;

	const KORAX_SPIRIT_LIFETIME 		= 5*TICRATE/5;	// 5 seconds
 
	//*******
	//*Korax*
	//*******
	//===========================================================================
	// Korax Variables
	//	tracer		last teleport destination
	//	special2	set if "below half" script not yet run
	//
	// Korax Scripts (reserved)
	//	249		Tell scripts that we are below half health
	//	250-254	Control scripts (254 is only used when less than half health)
	//	255		Death script
	//
	// Korax TIDs (reserved)
	//	245		Reserved for Korax himself
	//  248		Initial teleport destination
	//	249		Teleport destination
	//	250-254	For use in respective control scripts
	//	255		For use in death script (spawn spots)
	//===========================================================================
	void A_KoraxStep(statelabel melee = '_a_chase_default', statelabel missile = '_a_chase_default', int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0)
	{
		A_PlaySound("KoraxStep"); 
		A_DVDSChase(melee,missile,flags,type,value1,value2,value3,value4,value5); 
	}

	void A_KoraxChase()
	{
		
		int teleporthealth;
		if (User_MaxHP <= 0) teleporthealth = SpawnHealth()/2; else teleporthealth = User_MaxHP/2;
		if ((!special2) && (health <= (teleporthealth)))
		{
			ActorIterator it = ActorIterator.Create(KORAX_FIRST_TELEPORT_TID);
			Actor spot = it.Next ();
			if (spot != null)
			{
				Teleport ((spot.pos.xy, ONFLOORZ), spot.angle, TELF_SOURCEFOG | TELF_DESTFOG);
			}
			ACS_Execute(249, 0);
			special2 = 1;	// Don't run again
			return;
		}

		if (target == null)
		{
			return;
		}
		if (random[KoraxChase]() < 30)
		{
			SetState (MissileState);
		}
		else if (random[KoraxChase]() < 30)
		{
			A_PlaySound("KoraxActive", CHAN_VOICE, 1, false, ATTN_NONE);
		}

		// Teleport away
		int teleporthealth2;
		if (User_MaxHP <= 0) teleporthealth2 = SpawnHealth() >> 1; else teleporthealth2 = User_MaxHP >> 1;
		if (health < (teleporthealth2))
		{
			if (random[KoraxChase]() < 10)
			{
				ActorIterator it = ActorIterator.Create(KORAX_TELEPORT_TID);
				Actor spot;

				if (tracer != null)
				{
					// Find the previous teleport destination
					do
					{
						spot = it.Next ();
					} while (spot != null && spot != tracer);
				}

				// Go to the next teleport destination
				spot = it.Next ();
				tracer = spot;
				if (spot)
				{
					Teleport ((spot.pos.xy, ONFLOORZ), spot.angle, TELF_SOURCEFOG | TELF_DESTFOG);
				}
			}
		}
	}

	void A_KoraxDecide()
	{
		if (random[KoraxDecide]() < 220)
		{
			SetStateLabel ("Attack");
		}
		else
		{
			SetStateLabel ("Command");
		}
	}

	void A_KoraxBonePop()
	{
		// Spawn 6 spirits equalangularly
		for (int i = 0; i < 6; ++i)
		{
			Actor mo = SpawnMissileAngle ("KoraxSpirit", 60.*i, 5.);
			if (mo)
			{
				KSpiritInit (mo);
			}
		}
		ACS_Execute(255, 0);
	}

	private void KSpiritInit (Actor spirit)
	{
		spirit.health = KORAX_SPIRIT_LIFETIME;

		spirit.tracer = self;						// Swarm around korax
		spirit.WeaveIndexZ = 32 + (random[Kspiritnit]() & 7);	// Float bob index
		spirit.args[0] = 10; 						// initial turn value
		spirit.args[1] = 0; 						// initial look angle

		// Spawn a tail for spirit
		HolyTail.SpawnSpiritTail (spirit);
	}

	void A_KoraxMissile()
	{
		static const class<Actor> choices[] =
		{
			"WraithFX1", 

			"IceGuyFX", 

			"Demon1FX1", 
			"Demon2FX1", 
			"Demon3FX",
			"Demon4FX",
			"Demon5FX1",

			"FireDemonMissile", 
			"FireDemonLeaderMissile", 
			"FireDemonCommanderMissile", 
			"FireDemonQueenMissile", 

			"CentaurFX", 

			"SerpentFX", 

			"ThrownMace"
		};
		static const class<Actor> crisischoices[] =
		{
			"WraithFX1Crisis", 

			"IceGuyFXCrisis", 

			"Demon1FX1Crisis", 
			"Demon2FX1Crisis", 
			"Demon3FXCrisis",
			"Demon4FXCrisis",
			"Demon5FX1Crisis",

			"FireDemonMissileCrisis", 
			"FireDemonLeaderMissileCrisis", 
			"FireDemonCommanderMissileCrisis", 
			"FireDemonQueenMissileCrisis", 

			"CentaurFXCrisis", 

			"SerpentFXCrisis", 

			"ThrownMaceCrisis"
		};
		static const sound sounds[] = 
		{
			"WraithMissileFire", 

			"IceGuyAttack", 

			"DemonMissileFire", 
			"DemonMissileFire", 
			"DemonMissileFire", 
			"DemonMissileFire", 
			"DemonMissileFire", 

			"FireDemonAttack", 
			"FireDemonAttack", 
			"FireDemonAttack", 
			"FireDemonAttack", 

			"CentaurLeaderAttack", 

			"SerpentLeaderAttack", 

			"FighterHammerMiss"
		};
		int type = random[KoraxMissile]() % 14;

		A_PlaySound("KoraxAttack", CHAN_VOICE);

		// Fire all 6 missiles at once
		A_PlaySound(sounds[type], CHAN_WEAPON, 1, false, ATTN_NONE);

		A_MonsterCrisisCheck(); // Korax - Attack [Multiple (6) at once]
		class<Actor> info = choices[type];
		class<Actor> crisisinfo = crisischoices[type];

		// Throws out the fireballs form Korax's arms
		for (int i = 0; i < 6; ++i)
		{
			if (user_canusecrisisatk == 1) { A_PlayCrisisAtkSound(); KoraxFire(crisisinfo, i); } else { KoraxFire(info, i); }
		}
	}

	void KoraxFire (Class<Actor> type, int arm)
	{
		static const int extension[] =
		{
			KORAX_ARM_EXTENSION_SHORT,
			KORAX_ARM_EXTENSION_LONG,
			KORAX_ARM_EXTENSION_LONG,
			KORAX_ARM_EXTENSION_SHORT,
			KORAX_ARM_EXTENSION_LONG,
			KORAX_ARM_EXTENSION_LONG
		};
		static const int armheight[] =
		{
			KORAX_ARM1_HEIGHT,
			KORAX_ARM2_HEIGHT,
			KORAX_ARM3_HEIGHT,
			KORAX_ARM4_HEIGHT,
			KORAX_ARM5_HEIGHT,
			KORAX_ARM6_HEIGHT
		};

		double ang = angle + (arm < 3 ? -KORAX_DELTAANGLE : KORAX_DELTAANGLE);
		Vector3 pos = Vec3Angle(extension[arm], ang, armheight[arm] - Floorclip);
		SpawnKoraxMissile (pos, target, type);
	}

	private void SpawnKoraxMissile (Vector3 pos, Actor dest, Class<Actor> type)
	{
		Actor th = Spawn (type, pos, ALLOW_REPLACE);
		if (th != null)
		{
			th.target = self; // Originator
			double an = th.AngleTo(dest);
			if (dest.bShadow)
			{
				// Invisible target
				an += Random2[KoraxMissile]() * (45/256.);
			}
			th.angle = an;
			th.VelFromAngle();
			double dist = dest.DistanceBySpeed(th, th.Speed);
			th.Vel.Z = (dest.pos.z - pos.Z + 30) / dist;
			th.CheckMissileSpawn(radius);
		}
	}

	void A_KoraxCommand()
	{
		int numcommands;

		A_PlaySound("KoraxCommand", CHAN_VOICE);

		// Shoot stream of lightning to ceiling
		double ang = angle - 90;
		Vector3 pos = Vec3Angle(KORAX_COMMAND_OFFSET, ang, KORAX_COMMAND_HEIGHT);
		Spawn("KoraxBolt", pos, ALLOW_REPLACE);

		int commandhealth;
		if (User_MaxHP <= 0) commandhealth = SpawnHealth() >> 1; else commandhealth = User_MaxHP >> 1;

		if (health <= commandhealth)
		{
			numcommands = 5;
		}
		else
		{
			numcommands = 4;
		}

		ACS_Execute(250 + (random[KoraxCommand]()%numcommands), 0);
	}
}

#include "zscript/dvds-hexen-heresiarch.zc"


// MONSTER SPAWNERS

// Ettin
class EttinSpawner : AetheriusMonsterSpawner replaces Ettin
{
	override Name ChooseSpawn()
	{
		let evolveChance = CallACS("GetEvolveChance");
		
		if (random(1,1024) <= evolveChance)
		{
			if (random(1,4096) <= evolveChance)
				return "Bormereth";
			else
				return "EttinCommander";
		}
		else
			return "EttinNew";
	}
}

// Green Chaos Serpent Spawner
class Demon1Spawner : AetheriusMonsterSpawner replaces Demon1
{
	override Name ChooseSpawn()
	{
		let evolveChance = CallACS("GetEvolveChance");
		
		if (random(1,512) <= evolveChance)
		{
			if (random(1,16384) <= evolveChance)
				return "EtherealChaosSerpentNew";
			else
				return "MagmaChaosSerpentNew";
		}
		else
			return "GreenChaosSerpentNew";
	}
}

// Brown Chaos Serpent Spawner
class Demon2Spawner : AetheriusMonsterSpawner replaces Demon2
{
	override Name ChooseSpawn()
	{
		let evolveChance = CallACS("GetEvolveChance");
		
		if (random(1,512) <= evolveChance)
		{
			if (random(1,16384) <= evolveChance)
				return "EtherealChaosSerpentNew";
			else
				return "BlackChaosSerpentNew";
		}
		else
			return "BrownChaosSerpentNew";
	}
}

class AfritSpawner : AetheriusMonsterSpawner replaces FireDemon
{
	override Name ChooseSpawn()
	{
		let evolveChance = CallACS("GetEvolveChance");
		
		if (random(1,256) <= evolveChance)
		{
			if (random(1,512) <= evolveChance)
			{
				if (random(1,1024) <= evolveChance)
					return "FireDemonQueen";
				else
					return "FireDemonCommander";
			}
			else
				return "FireDemonLeader";
		}
		else
			return "FireDemonNew";
	}
}

class BishopSpawner : AetheriusMonsterSpawner replaces Bishop
{
	override Name ChooseSpawn()
	{
		let evolveChance = CallACS("GetEvolveChance");
		
		if (random(1,256) <= evolveChance)
		{
			if (random(1,512) <= evolveChance)
			{
				if (random(1,1024) <= evolveChance)
					return "DarkPatriarch";
				else
					return "VampireDVDS";
			}
			else
				return "DarkDisciple";
		}
		else
			return "BishopNew";
	}
}

class StalkerSpawner : AetheriusMonsterSpawner replaces Serpent
{
	override Name ChooseSpawn()
	{
		let evolveChance = CallACS("GetEvolveChance");
		
		if (random(1,256) <= evolveChance)
			return "IceStalker";
		else
			return "StalkerNew";
	}
}

class StalkerLeaderSpawner : AetheriusMonsterSpawner replaces SerpentLeader
{
	override Name ChooseSpawn()
	{
		let evolveChance = CallACS("GetEvolveChance");
		
		if (random(1,256) <= evolveChance)
			return "IceStalkerLeader";
		else
			return "StalkerLeaderNew";
	}
}

class PatriarchRadiusHeal : AetheriusCustomInventory
{
	default
	{
		Inventory.MaxAmount 1;
		+Inventory.AUTOACTIVATE
	}

	override void Tick()
	{
		Console.Printf("e324");
		let healactor = AetheriusMonsterZSC(owner);
		if (healactor)
		{
			if (healactor.health > 0 && healactor.health < healactor.user_MaxHP) { healactor.health += random(10,12); }
		}
		super.Tick();
	}

	States
	{
		Use:
			TNT1 A 0;
			Stop;
	}
}